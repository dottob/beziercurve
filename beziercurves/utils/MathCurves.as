package beziercurves.utils {	import flash.geom.Point;			/**	 * Copyright (c) 2008 nicolas levavasseur	 * nicolas.levavasseur@gmail.com	 * 	 * @author nicolas levavasseur	 */	public class MathCurves {		public static const UNIFORM_KNOT_VECTOR:String = "uniform";		public static const OPEN_UNIFORM_KNOT_VECTOR:String = "openUniform";		public static const NON_UNIFORM_KNOT_VECTOR:String = "nonUniform";				public function MathCurves() {			throw new Error("MathCurves is a static class, you cannot instanciate it.");		}		public static function fact(n:int):Number {			if( n == 0 ) return 1;			return n * fact(n-1);		}				public static function binomialCoeff(n:int, k:int):Number {			return fact(n) / (fact(k) * fact(n - k));		}				public static function B(i:int, n:int, t:Number):Number {			return binomialCoeff(n - 1, i) * Math.pow(1 - t, n - 1 - i) * Math.pow(t, i);		}				public static function N(i:int, p:int, t:Number, T:Array):Number {			var ti:Number = T[i];			var ti1:Number = T[i + 1];						if( p == 0 ){				if( ti <= t && t < ti1 && ti < ti1 ) return 1;				return 0;			}						var tip:Number = T[i + p];			var tip1:Number = T[i + p + 1];						return (t - ti) / (tip - ti) * N(i, p - 1, t, T) + (tip1 - t) / (tip1 - ti1) * N(i + 1, p - 1, t, T);		}				public static function knotVector(precision:int, type:String = MathCurves.UNIFORM_KNOT_VECTOR, k:int = 1):Array {			if( k < 1 ) k = 1;			var T:Array = [];			for(var i:int = 0; i <= precision; i++){				switch( type ){					case MathCurves.UNIFORM_KNOT_VECTOR:						T.push(i / precision);						break;					case MathCurves.OPEN_UNIFORM_KNOT_VECTOR:						if( i < k ) T.push(0);						else if( i <= precision - k ) T.push((i - k + 1) / precision);						else T.push(1);						break;				}			}			return T;		}				public static function multPoint(r:Number, p:Point):Point {			return new Point(r * p.x, r * p.y);		}				public static function addPoints(p0:Point, p1:Point):Point {			return new Point(p0.x + p1.x, p0.y + p1.y);		}	}}